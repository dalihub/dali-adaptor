/*
 * Copyright (c) 2024 Samsung Electronics Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// CLASS HEADER
#include <dali/internal/graphics/vulkan-impl/vulkan-texture-dependency-checker.h>

// EXTERNAL INCLUDES
#include <dali/internal/graphics/vulkan-impl/vulkan-render-target.h>
#include <dali/internal/graphics/vulkan-impl/vulkan-texture.h>

// INTERNAL INCLUDES

namespace Dali::Graphics::Vulkan
{
void TextureDependencyChecker::Reset()
{
  for(auto& dependency : mDependencies)
  {
    dependency.generator->ResetDependencies();
  }

  mDependencies.clear();
  mCurrentIndex = 0;
}

void TextureDependencyChecker::AddTexture(const Vulkan::Texture* texture, Vulkan::RenderTarget* renderTarget)
{
  // We only push attachments into this struct, so total size should be low.
  // Note, Textures may be written to more than once in a frame, so always add new target generator
  mDependencies.push_back(TextureDependency{texture, renderTarget});
}

void TextureDependencyChecker::CheckNeedsSync(const Vulkan::Texture* texture, Vulkan::RenderTarget* renderTarget)
{
  // Check if this texture was generated as a dependency. It could be generated by more than one
  // target in a frame, so work backwards from the latest render pass.
  for(auto iter = mDependencies.rbegin(); iter < mDependencies.rend(); ++iter)
  {
    if(iter->texture == texture)
    {
      renderTarget->AddDependency(iter->generator);
      break;
    }
  }
}

void TextureDependencyChecker::AddRenderTarget(Vulkan::RenderTarget* renderTarget)
{
  // We only add/remove on create/destroy, so guarantee uniqueness
  mRenderTargets.push_back(renderTarget);
}

void TextureDependencyChecker::RemoveRenderTarget(Vulkan::RenderTarget* renderTarget)
{
  for(auto iter = mRenderTargets.begin(); iter != mRenderTargets.end(); ++iter)
  {
    if(*iter == renderTarget)
    {
      mRenderTargets.erase(iter);
      break;
    }
    else
    {
      (*iter)->RemoveDependency(renderTarget);
    }
  }
}

} // namespace Dali::Graphics::Vulkan
