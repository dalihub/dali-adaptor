/*
 * Copyright (c) 2025 Samsung Electronics Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// CLASS HEADER
#include <dali/internal/graphics/vulkan-impl/vulkan-texture-dependency-checker.h>

// EXTERNAL INCLUDES
#include <dali/internal/graphics/vulkan-impl/vulkan-render-target.h>
#include <dali/internal/graphics/vulkan-impl/vulkan-texture.h>

// INTERNAL INCLUDES

namespace Dali::Graphics::Vulkan
{
void TextureDependencyChecker::Reset()
{
  // @todo Only reset if render instructions have changed this frame
  // But, if we aren't resetting, also need RemoveRenderTarget to erase generator

  // First, remove dependencies from render targets
  for(auto& renderTarget : mRenderTargets)
  {
    renderTarget->ResetDependencies();
  }
  // Then, drop all our tables, bobby.
  mLookupByTexture.clear();
  mLookupByRenderTarget.clear();
  mTextureGenerators.clear();
}

void TextureDependencyChecker::AddTexture(Vulkan::Texture* texture, Vulkan::RenderTarget* renderTarget)
{
  // Note, Textures may be written to more than once in a frame, so always add new target generator
  const auto iter = mLookupByTexture.find(texture);

  if(iter == mLookupByTexture.end())
  {
    mTextureGenerators.emplace_back(TextureGenerator{texture, {renderTarget}});
    mLookupByTexture.insert({texture, mTextureGenerators.size() - 1});
    mLookupByRenderTarget.insert({renderTarget, mTextureGenerators.size() - 1});
  }
  else
  {
    mTextureGenerators[(*iter).second].generators.emplace_back(renderTarget);
    mLookupByRenderTarget.insert({renderTarget, (*iter).second});
  }
}

void TextureDependencyChecker::CheckNeedsSync(Vulkan::Texture* texture, Vulkan::RenderTarget* renderTarget)
{
  // Check if this texture was generated as a dependency. It could be generated by more than one
  // target in a frame, so use the latest generator only.

  const auto iter = mLookupByTexture.find(texture);
  if(iter != mLookupByTexture.end())
  {
    auto& tg = mTextureGenerators[(*iter).second];
    renderTarget->AddDependency(tg.generators.back());
  }
}

void TextureDependencyChecker::AddRenderTarget(Vulkan::RenderTarget* renderTarget)
{
  // These are targets using textures, i.e. dependent render targets
  // Only added on creation, so guarantees uniqueness
  mRenderTargets.push_back(renderTarget);
}

void TextureDependencyChecker::RemoveRenderTarget(Vulkan::RenderTarget* renderTarget)
{
  // In theory, we should only be removing during message processing/discard, so we should
  // be outside a frame. However, lets try and clean up anyway.
  auto iter = mLookupByRenderTarget.find(renderTarget);
  if(iter != mLookupByRenderTarget.end())
  {
    auto& textureGenerator = mTextureGenerators[(*iter).second];
    auto  genTexture       = textureGenerator.texture;
    auto& generators       = textureGenerator.generators;
    auto  genIter          = std::find(generators.begin(), generators.end(), renderTarget);
    if(genIter != generators.end())
    {
      // We have a texture generator. Erase the render target from this list.
      textureGenerator.generators.erase(genIter);
      if(textureGenerator.generators.empty())
      {
        // If this was the last generator of the texture, erase the texture generator.
        auto textureIter = mLookupByTexture.find(genTexture);
        mLookupByTexture.erase(textureIter);
        // Ignore mTextureGenerators, it's getting dropped at the beginning of the next frame.
      }
    }
    mLookupByRenderTarget.erase(iter);
  }
  auto eraseIter = mRenderTargets.end();
  for(auto iter = mRenderTargets.begin(); iter != mRenderTargets.end(); ++iter)
  {
    // Save off the iter
    if(*iter == renderTarget)
    {
      eraseIter = iter;
    }
    else
    {
      // Ensure it's removed from all other render targets
      (*iter)->RemoveDependency(renderTarget);
    }
  }
  if(eraseIter != mRenderTargets.end())
  {
    // Erase from list using saved iter
    mRenderTargets.erase(eraseIter);
  }
}

} // namespace Dali::Graphics::Vulkan
